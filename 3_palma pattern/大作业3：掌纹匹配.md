# 大作业3：掌纹匹配

18373156   曾博涵

### 任务目标

+ 实现判断任意两张掌纹图片是否为同一掌纹

### 任务实现方法

+ 利用孪生神经网络作为框架，CNNs作为backbone network，输入的是一对掌纹图片，输出1或者0，判断这一对掌纹图片是否属于同一个人。

### 任务实现具体过程

+ **数据集构建**

  ​		这一部分我主要利用了DataLoader(主要是想利用其中的shuffle)，构建方法简单来说就是有1/4的数据一定是同一组的指纹，而另外3/4的数据是随机生成的一对指纹，这一对指纹不在同一组的概率要远远大于在同一组的概率，指纹源自同一组的话label为1，不在同一组的话label为0。

+ **卷积神经网络(backbone network)设计**

  ​		简而言之就是三层卷积，卷积核尺寸分别为5\*5、3\*3、3\*3，输出feature maps数量分别为10、20、30；四层池化池化矩阵大小均为2*2；三层全连接层，输出一个40维向量作为图片的特征向量。

+ **孪生神经网络结构设计**

  ​		孪生神经网络的主要结构包括了两个backbone network，输入两张图片，分别输入到两个backbone network之中，输出两个40维向量，计算这两个向量的欧式距离，当欧式距离小于设定好的$\alpha$，判定这两个掌纹同属于同一个人，当欧式距离大于$\alpha$时，则输入两张掌纹不是同一个人。

+ **损失函数设计**

  ​		损失函数使用的是专用于孪生神经网络的Contrastive_loss，目的在于当label为0时让两个向量欧氏距离变大，当label为1时让两个向量的欧氏距离变小，具体公式为：
  $$
  Loss=(1-label)*EuclideanDistance^2+label*(2-EuclideanDistance)^2
  $$

### 实验工程中的纠错

最开始我有一个比较严重的错误就在于

### 实验结果

不论是1600组图片的训练结果还是3200组图片的训练结果，效果都还是不错的



### 实验的遗憾

主要是我想延长显卡的寿命，因此backbone network主要使用的是较为轻量级的卷积神经网络，