# 大作业1：无人机规划

18373156   曾博涵

### 个人完成任务列表：

+ 实现了多无人机路线规划，并分析了发布代码的调用关系
+ 在dangerMatrix中添加了两种robot对于无人机G矩阵影响方式，并进行分析
+ 用python语言以及dijskra算法思路进行重构
+ 提出使用蒙特卡洛树的思路

### 源代码解读

+ 调用关系为：main_UAVs(每当见到新的敌人时使用planning)$\rightarrow$planning(获得当前点到target的全部路线)$\rightarrow$dangerMatrix(用于计算当前某一个点距图中所有点权重值，包括了已知敌人)$\rightarrow$nextstep(在dangerMatrix中计算积分使用)。
+ 如何添加多无人机：描述一个无人机行进过程主要有这样几个变量：enemysUK、enemysK、INITIAL、pos、TRACE、tracerecord等，添加多无人机思路非常简单，只要将上述变量变成数组，在使用时加一层for循环对应处理就可以，因为本人动手实践比较早，做了双无人机移动，没有使用数组，将每一个变量分开两个处理(例如：pos_1、pos_2)，因此也没有加for循环，但思路是一致的，因此我没有修改，减少无用功
+ 无人机间避障：由于无人机始终在向着target移动，对于重复点不会来回运动，因此一个比较好的思路是直接将其他无人机出现位置列为障碍即可。

### 原方法进一步分析：

​       由于planning的路线完全取决于dangerMatirx所返回的权值矩阵，当完全只有敌人时，根据"威胁矩阵"(即代码中的E矩阵)，通过"近似积分求和"的方式来计算起点s到其他所有点过程中受敌人的威胁程度，以及s到其他点的距离，计算s到其他所有点的权重距离。那么我们添加机器人的思路也很简单，只要当其他点在robot可服务范围内，那么无人机与这个点的之间的权重距离就减去$M*\sum_{i=1}^{nr}robot\_importance_i[ pot\quad in robot\_scale_i]$，其中M为参数，nr为机器人的总个数，也就是说减去的值是这个点可服务机器人的重要程度之和乘一个系数，根据实验结果来看，M不可以太大，太大的话会始终运行不到终点，最终我的M系数为0.4。

+ 上述方法参考的公式为

  $$
  A_{p_1,p_2}=Dis_{p_1,p_2}+K\int F(x,y)ds-M\sum_{i\in R}D_i
  $$
  


​		而最终的权重矩阵D更新以及路线选择均在planning.m中完成，更新思路为首先初始化一个N*N的全1矩阵，然后吧target坐标处的矩阵值改为0，将坐标s初始化为target，随后每轮开始随机选择s，每轮计算s点的danger矩阵A，并且以以下公式进行权重矩阵的更新
$$
D=min(D,D(s)+A)
$$
​		由于添加机器人仅在dangerMatirx中就可以完成，因此planning.m不需要修改。

+ 运行效果截图

![第一部分运行结果示意图](D:\university\2020_autumn\机器学习\大作业实验报告\大作业1：无人机规划\第一部分运行结果示意图.png)

### 使用dijskra算法进行任务重构

​		我个人认为这类寻路问题，与其使用R-learning的方法，不如使用图算法来的更加直接，比如说本文使用的贪心算法dijskra，算法主要用两个矩阵分别为min_value与map，map记录的是图中任意两点之间的代价，min_value矩阵记录了当前点到其他所有点之间的距离。

​		整个代码大致流程是，每当运行一次算法之后，沿着向target的最短路径走UAV一次可以行动的最大步长，来到一个新的点上，观察到新的敌人，与此同时更新map矩阵，若有新的敌人，则在当前点重新运行一次dijskra算法，直到无人机来到target点之后，算法结束。

+ 运行效果截图

![dijskra_result](D:\university\2020_autumn\机器学习\大作业实验报告\大作业1：无人机规划\dijskra_result.png)